<!doctype html>  
<html lang="en">  
 <head>  
  <meta charset="UTF-8">  
  <meta name="Generator" content="EditPlus®">  
  <meta name="Author" content="">  
  <meta name="Keywords" content="">  
  <meta name="Description" content="">  
  <title>Document</title>  
  <style>  
    canvas{  
        background:#eee;  
        border: 2px solid deepskyblue;  /*给画布添加一个深蓝色边框*/
    }  
  </style>  
  <script>  
  
    var x = 0; // canvas画布原点x  
    var y = 0; // canvas画布原点y  
    var x_base = x; // 我们要画的波形图的最后一个点的x坐标  
    var y_base = 50; // 我们要画的波形图的最后一个点的y坐标  也是起始显示的坐标
    var arrPoint = []; // 用于保存已经波形图的轨迹点  
    var index = 0; // 这个我是用来打日志用的..下面为了看清除了多少次canvas画布  
    var step = 50; // x轴每次走的步长  4   注意：这里最好step可以被width整除，不然的话，会出现最后一个点的横坐标x到不了边界上；
    var width=500; // 这个是画布宽度  
    var height=100; // 这个是画图高度  
    //  var itv;

    function drawChart() {
        // 获取canvas对象和context,并进行一系列初始化  
        var canvas = document.getElementById("canvas");  
        var context = canvas.getContext("2d");  
        context.strokeStyle = "deepskyblue";  // strokeStyle 属性设置或返回用于笔触的颜色、渐变或模式。
        context.fileStyle = "deepskyblue";  
  
        // 画图之前首先清理一下我们的画布,四个参数.  
        // 1.坐标原点x  
        // 2.坐标原点y  
        // 3.要清理的宽度(这里宽度用的x_base是因为canvas画布的原点不断向左移动，变相的等于画布不断变宽  
        //   之所以减一个step是需要看下文,因为在下文中,x_base每一次都会增加一个step,而我们在清理画布的时候,  
        //   我们的画布原点还没有被移动,相当于我们在清除画布时,我们的画布宽度还没有增加,所以要减一个step,当然不减也可以,没事儿)  
        // 4.画布高度  
        context.clearRect(0,0,x_base-step,height);  //clearRect() 方法清空给定矩形内的指定像素。context.clearRect(x,y,width,height);
        if(x_base > width){  
            console.log("clear canvas times:" + index);  
            index++;  
            // 画布原点x轴向左移动一个step的位置  
            context.translate(step*-1,0);   // translate() 方法重新映射画布上的 (0,0) 位置。
        }  
              
        // 向数组中添加数据,将我们每一次目标到达的终点坐标添加到数组中.这里我设置的条件是,保证数组大小不会超过我的画布宽度除以step个  
        // 目的是针对画布定的,就是每一次我只画画布这么大小的图  
        var obj = [];  // 局部变量数组，每次重新生成，用于存放坐标值（x，y）
        obj.x = x_base;  
        obj.y = y_base; 
        console.log(obj); 
        if(arrPoint.length>(width/step)){  // 当已存图形坐标数，超过width画布上能画的点数，开始清理已存数组的第一组x,y值（数组）；
            arrPoint.splice(0,1);  // 每次去掉已存的画布数组中的第一个值：相当于左移一个step；
            console.log(arrPoint);  
        }  
        arrPoint.push(obj);  // 将坐标数组放到全局数组中保存起来；都是线条一一对应的坐标；
              
        // 开始画了,在画之前先将所有的图形都画出来  
        context.beginPath();  // 开始一条路径或是重置当前的路径
        for(var i = 0; i < arrPoint.length; i++){  
            context.lineTo(arrPoint[i].x,arrPoint[i].y);  
  
        }  
        // 再一次性将所有图形呈现在html上  
        context.stroke();  // stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。
        context.closePath();  // closePath() 方法创建从当前点到开始点的路径。
  
        // OK,这时候已经花完了,现在要算一算我们的下一个目标点的坐标了,算完了以后,保存在一个全局变量中  
        // 等待下次再执行画图函数时,将变量添加到数组中,让canvas画图使用  
        // 下一个坐标的X
        x_base += step;
        // 下一个坐标的Y
        y_base = 50 + Math.random() * 50;  //       
    }

    // (function (){  
    //     // 首先让我们的函数周期调用  
    //     itv = setInterval(function(){ 
    //     },1000)  
    // })()  

    function clearCanvas() {
        console.log("trigger clearCanvas() function");
        clearInterval(itv);
        var canvas = document.getElementById('canvas');  
        var context = canvas.getContext("2d");  

        console.log("the last (x, y), x="+x_base);
        console.log("the last (x, y), y="+y_base);
        context.clearRect(0,0,x_base-step,height);    // 最后的画点，在
    }
  
  </script>  
 </head>  
 <body>  
    <canvas id="canvas" width="500" height="100">  
        你这不行啊..不支持canvas  
    </canvas>  
    <button id="clear" onclick="clearCanvas()">clear canvas</button>
    <button id="waveform" onclick="drawChart()">add waveform</button>
 </body>  
</html>  